#!/bin/bash

# Welcome back to Hacklandia.

##################################################
# Imports
##################################################

. ScriptFunctions
Import OptionParser
Import File
Import String
Import Terminal
Import GoboLinux
Import Array
Import Directories
Import PostInstall
Import Versions
Import Requirements
Import Archive
Import UnionFS

##################################################
# Checking Scripts package version
##################################################

scriptsversion=`Get_Version Scripts Current`

if echo "$scriptsversion" | grep -qi GIT || \
   echo "$scriptsversion" | grep -qi SVN || \
   [ "`GuessLatest $scriptsversion 2.9.5`" = "$scriptsversion" ]
then
   # Version is valid, proceed.
   :
else
   Die "Your Scripts package is too old. Please update it by running 'InstallPackage Scripts'."
fi

##################################################
# Options and configuration
##################################################

helpOnNoArguments=yes
scriptDescription="Automated program compilation tool."
scriptCredits="(C)2003-2007 by Hisham Muhammad et al. Released under the GNU GPL."
scriptUsage="<program> [<version>]"
Add_Option_Entry "n" "app-name" "Override application name." ""
Add_Option_Entry "e" "version-number" "Override version number." ""
Add_Option_Entry "x" "cross-compile" "Cross-compile to another architecture." ""
Add_Option_Entry "c" "configure-options" "Options to be passed explicitly to './configure'." ""
Add_Option_Boolean "k" "keep" "Keep files if program directory already exists."
Add_Option_Boolean "b" "batch" "Batch mode: avoid asking questions."
Add_Option_Boolean "B" "no-build" "Do not build, just fetch the sources."
Add_Option_Boolean "I" "no-install" "Do not actually install the program."
Add_Option_Boolean "W" "no-web" "Do not check remote site for recipes, and bypass fetching of archives."
Add_Option_Boolean "S" "no-symlink" "Do not symlink. Deprecated - use --symlink=no instead."
Add_Option_Entry   "l" "symlink" "If symlinks should be created and wether they should be forced on conflicts."  "yes" "yes no force"
Add_Option_Boolean "T" "no-strip" "Do not strip executables."
Add_Option_Boolean "G" "no-sign" "Do not sign program."
Add_Option_Boolean "U" "no-updatesettings" "Do not update settings for the program"
Add_Option_Boolean "M" "no-unmanaged" "Do not install unmanaged files."
Add_Option_Boolean "L" "lazy" "'Lazy mode': cut some corners when rebuilding; debugging aid: do NOT use it for building packages."
Add_Option_Entry   "A" "start-at" "Skip sub-recipes when building a meta-recipe: start include list at given recipe; effective only with --lazy; debugging aid: do NOT use it for building packages."
Add_Option_Boolean "D" "no-dependencies" "Do not try to fulfill dependencies."
Add_Option_Boolean "i" "install-separately" "If the application is part of a meta recipe, do not install it into the containing application but install it into a separate directory."
Add_Option_Boolean "a" "remove-archive" "Remove archive(s) after a successful build"
Add_Option_Boolean "s" "remove-sources" "Remove sources after a successful build"
Add_Option_Boolean "P" "no-postinstall" "Do not run the PostInstall script after installation"
Add_Option_Boolean "R" "no-requirements" "Do not process the Requirements script after installation"

Parse_Conf Compile.conf
Parse_Options "$@"

if [ -z "$ROOTLESS_GOBOLINUX" ] && ! $sudo_validate
then
   Ask "You are trying to compile $(Arg 1) as normal user without privileges.\n\
Should a rootless environment be set up instead?" && {
      CreateRootlessEnvironment && . ~/Programs/Rootless/Current/bin/StartRootless
   }
fi

[ "$compileFlags" ] && Parse_Options $compileFlags

Boolean "lazy" && Set_Boolean "no-web"
Boolean "no-web" && noweb="--no-web"
Boolean "batch" && batch="--batch"
Boolean "verbose" && verbose="--verbose"
Boolean "no-build" && Set_Boolean "keep"
Boolean "no-install" && no_install=yes

if Is_Entry "configure-options"
then userconfigureoptions=(`Entry "configure-options"`)
else userconfigureoptions=()
fi

if [ "$compileDisableSudo" = "yes" ]
then sudo_exec=
fi

make="${compileMakeCommand:-ColorMake}"
chown="${compileChownCommand:-chown}"

# Options to be propagated in sub-calls to Compile
unset compileoptions
Is_Entry cross-compile && compileoptions="$compileoptions --cross-compile `Entry cross-compile`"
Boolean no-install && compileoptions="$compileoptions --no-install"
Boolean no-build && compileoptions="$compileoptions --no-build"
Boolean no-web && compileoptions="$compileoptions --no-web"
Boolean batch && compileoptions="$compileoptions --batch"
Boolean lazy && compileoptions="$compileoptions --lazy"
Is_Entry symlink && compileoptions="$compileoptions --symlink=$(Entry symlink)"
Boolean "remove-archive" && compileoptions="$compileoptions --remove-archive"
Boolean "remove-sources" && compileoptions="$compileoptions --remove-sources"

compileInstallOptions=(
   "GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1"
)

### Temporary test for those tracking SVN ###
PrepareProgram --help | grep -q no-default-options || Die "Please update your Scripts snapshot."

trap undo_mounts TERM INT STOP HUP

#############################################

##################################################
# Helper functions
##################################################

Import Compile

function wrapup() {
   Post_Installation_Clean_Up "$appname" "$versionnumber"
   if [ "$app" = "$appname" ]
   then
      # Add information inside binary package Resources directory
      Quiet mkdir -p $target/Resources

      # Save use flags information
      echo "${useflags[*]}" | $sudo_exec tee "$target/Resources/UseFlags" >/dev/null || wrap_fail "Failed installing file."

      if [ ! -z "$cross_uname_m" ]
      then echo "$cross_uname_m" | $sudo_exec tee "$target/Resources/Architecture" >/dev/null || wrap_fail "Failed installing file."
      else echo "$(Get_Architecture)" | $sudo_exec tee "$target/Resources/Architecture" >/dev/null || wrap_fail "Failed installing file."
      fi

      Log_Normal "Generating package's build information..."
      GenBuildInformation --store "$appname" "$versionnumber" || wrap_fail "Failed installing build information file."

      if ! Boolean "no-sign"
      then
         if [ -e "$target/Resources/Dependencies" ]
         then
            Log_Normal "Generating package's signature..."
            SignProgram "$appname" "$versionnumber"
         else
            Log_Terse "Program does not have a Resources/Dependencies file."
            Log_Terse "Not signing it yet."
         fi
      fi
   fi
   # Some additional actions for LocalRecipes (adding info inside Resources, packing)
   if Starts_With "$compileLocalRecipesDir" "$reciperesources" && [ ! "$ROOTLESS_GOBOLINUX" = "1" ]
   then
      if [ "$app" = "$appname" ]
      then
         recipedeps="$reciperesources/Dependencies"
         Quiet mkdir -p "$reciperesources"

         cp "$target/Resources/BuildInformation" "$reciperesources/BuildInformation" || wrap_fail "Failed installing file."

         if [ ! -f "$recipedeps" ]
         then
            cp "$target/Resources/BuildInformation" "$recipedeps" || wrap_fail "Failed installing file."
            Log_Verbose $(cat "$recipedeps")
         fi
      fi
      packerror=
      if ! Boolean "batch"
      then
         Log_Normal "Packing recipe directory..."
         PackRecipe $noweb "$app" "$versionandrevision" || {
            Log_Error "Failed packing recipe."
            packerror=yes
         }
      fi
      Log_Normal "You are encouraged to submit your recipe for inclusion into the distribution."
      if [ "${packerror}" == "yes" ]
      then 
         Log_Terse "You need to fix the errors reported by RecipeLint before running 'ContributeRecipe $app $versionandrevision'."
      else
         Log_Normal "Please run 'ContributeRecipe $app $versionandrevision' to do this."
      fi
   fi
   if [ -n "$post_install_message" ]
   then
      Log_Normal "$app: $post_install_message"
   fi
   cleanup
}

function undo_mounts() {
   if Is_Entry "cross-compile" && Union_Is_Supported
   then 
       Quiet Union_Umount $(Union_Backend) $cross_libc_libdir
       for i in $goboPrograms/*/Current
       do [ -d "$i/lib" ] && Quiet Union_Umount $(Union_Backend) $i
       done
   fi
   [ "$1" = "--dont-exit" ] && return || exit 1
}

function wrap_fail() {
   local message="${1}"
   # Rollback left-over stuff when compilation fails.
   if [ -e "$target" ]
   then
      PrepareProgram --tree-cleanup $batch "$appname" "$versionnumber"
      Quiet rmdir -p "$target"
      Quiet rmdir -p "$settings_target"
      Post_Installation_Clean_Up "$appname" "$versionnumber" "failed"
   fi
   undo_mounts "--dont-exit"
   Die "$appname $versionnumber - $message"
}

function cleanup() {
   if [ -d "$installprefix-Compile-old" ]
   then
      if Boolean "batch"
      then REPLY=y
      else Ask_Option "Remove $installprefix-Compile-old (backup from safe linking)? [y/N]"
      fi
      [ "$REPLY" = "y" -o "$REPLY" = "Y" ] && $sudo_exec rm -rf "$installprefix-Compile-old"
   fi
   Boolean "remove-archive" && Map remove_archives "${files[@]}"
   Boolean "remove-sources" && Map remove_source_dir "${dirs[@]}"
   undo_mounts "--dont-exit"
   exit 0
}

function remove_archives() {
   rm -f "$1"
}

function remove_source_dir() {
   rm -rf "$1"
}

function check_direct_dependencies() {
   local fullversion="$2"
   if [ -d ${goboShared}/Compile/Recompile/${appname} -o -L ${goboShared}/Compile/Recompile/${appname} ]
   then
      for i in ${goboShared}/Compile/Recompile/${appname}/*
      do
         depapp=`basename $i`
         # An application cannot depend on itself
         [ "$(Downcase ${depapp})" == "$(Downcase ${appname})" ] && continue
         Boolean "batch" || Ask "${depapp} depends directly on ${appname}. Would you like to compile it?" || continue
         Compile $batch $lazy $noweb $depapp
      done
   fi
}

function combine_arrays() {
   merge="$1=("
   shift
   while [ "$1" ]
   do eval '[ -n "${'$1'[*]}" ] && merge=$merge'\'' "${'$1'[@]}" '\'
      shift
   done
   merge=$merge")"
   echo "$merge"
}

function in_host() {
   if [ "$goboCrossCompiling" = "yes" ]
   then
      unset goboCrossCompiling goboPrefix
      "$@"
      ret=$?
      export goboCrossCompiling=yes
      Parse_Conf Directories.conf
      return $ret
   else
      "$@"
   fi
}

function config_is_autoconf() {
   [ "$configure" ] || configure="./configure"
   grep -i "Generated .* autoconf" "$dir/$configure" &> /dev/null
}

function build_tree_if() {
   if [ "$@" ]
   then
      PrepareProgram --tree $batch --keep "$appname" "$versionnumber" || Die "Cannot build program tree."
   fi
}

function mark_export() {
   export variablestoexport="$variablestoexport $*"
}

function export_marked() {
   for var in $variablestoexport
   do
      export $var
   done
}

function setup_sandbox_options() {
   [ "${unmanaged_files[*]}" ] &&
   for unmanaged in "${unmanaged_files[@]}"
   do
      unmanagedlist="${unmanaged}${unmanagedlist:+:$unmanagedlist}"
   done
   if [ "$goboIndex" ]
   then sandboxopts=()
   else sandboxopts=$(merge_array "sandbox_options")
   fi

   subdirs=$(echo "${odir%/}" | tr '/' '\n' | wc -l)
   [ "$needs_build_directory" ] && subdirs=$[${subdirs}+1]
   [ $subdirs -gt 1 ] && sandboxopts=("--expand-sandbox $[subdirs-1]" "${sandboxopts[@]}")
}

function make_and_cd_to_build_dir() {
   if [ "$needs_build_directory" = "yes" ]
   then
      builddir="${sourcedir}/_build"
      mkdir -p "$builddir"
      cd "$builddir"
   fi
}

##################################################
# Prepare Environment
##################################################

Check_Dir_Variable compileDir
[ -z "$ROOTLESS_GOBOLINUX" ] && $sudo_exec chown `whoami` "${compileDir}"
[ "${compileRecipeDirs[*]}" ] || Die "Array \$compileRecipeDirs is not set. Please update your Compile.conf."
for compileRecipeDir in "${compileRecipeDirs[@]}"
do
   Assert_Dir "$compileRecipeDir"
done
Check_Dir_Variable compileDependenciesDir
Check_Dir_Variable compileArchivesDir
Check_Dir_Variable compileSourcesDir
Check_Dir_Variable compilePackedRecipesDir
[ -z "$ROOTLESS_GOBOLINUX" ] && $sudo_exec chown `whoami` "${compileSourcesDir}"

##################################################
# Find and Get Recipe
##################################################

#unset directrecipe
# support for direct recipe passing
if [ -f "$(Arg 1)/Recipe" -o "`echo $(Arg 1) | grep "/"`" ] || Ends_With "--recipe.tar.bz2" "$(Arg 1)"
then
   #directrecipe=yes
   rawrecipes="$(Arg 1)"
   Log_Normal "Using passed recipe $rawrecipes"
else
   app="$(Arg 1)"
   versionandrevision="$(Arg 2)"
   version="`String_Version "$versionandrevision"`"

   # Find recipe:
   Log_Normal "Locating a recipe for $app $versionandrevision..."
   String_To_Array rawrecipes "`FindPackage $noweb --full-list --type=recipe "$app" "$versionandrevision" 2> /dev/null`"
   [ "${rawrecipes[*]}" ] || {
      FindPackage $noweb --type=recipe "$app" &> /dev/null && {
         Log_Terse "Could not find recipe for $app $versionandrevision."
         { Boolean "batch" || Ask_Continue "Attempt to create recipe for version $version?"
         } && NewVersion $app $version "$(Arg 3)"  && {
            String_To_Array rawrecipes "`FindPackage $noweb --full-list --type=recipe "$app" "$version" 2> /dev/null`"
         }
      }
   } || Die_With $errorNotFound "Could not find recipe for $app $versionandrevision"
   Log_Normal "Found recipe for $app $versionandrevision"
fi

bakedrecipedir=`in_host GetRecipe "${rawrecipes[@]}"`
[ "$bakedrecipedir" ] || Die "Error getting recipe"
Log_Normal "Recipe placed in $bakedrecipedir"

[ -f "$bakedrecipedir/Recipe" ] || Die "$bakedrecipedir/Recipe not found"
recipe=$bakedrecipedir/Recipe

##################################################
# Check if we are cross-compiling
##################################################

unset STRIP
Is_Entry "cross-compile" && export goboCrossCompiling=yes cross_compiling=yes

if [ "$goboCrossCompiling" = "yes" ]
then
   arch_conf=`Entry "cross-compile"`
   Log_Normal "Cross-Compiling for $arch_conf"

   crossConfFile=${goboPrograms}/Compile/Settings/Compile/Cross/Cross-$arch_conf.conf
   [ ! -f "$crossConfFile" ] && Die "Could not find $crossConfFile."

   source "${goboPrograms}/Compile/Settings/Compile/Cross/Cross-ResetEnv.conf"
   source "${crossConfFile}"
   source GoboPath
   Parse_Conf Directories.conf

   # Extra arguments to be passed to 'make' and 'make install'
   cross_make_variables=(
      "CC=$CC"
      "CPP=$CPP"
      "CXX=$CXX"
      "LIBTOOL=$LIBTOOL"
      "CROSS=$cross_compiler"
   )
   # ARCH is taken from the cross config file
   arch=`Get_Architecture $cross_uname_m`
   archsubdir=$bakedrecipedir/$arch
   archrecipe=$bakedrecipedir/$arch/Recipe
   compileSourcesDir="$compileDir/Sources-$arch_conf"
   mkdir -p $compileSourcesDir

   if Union_Is_Supported
   then
       uniondirs="$cross_libc_libdir=rw"
       for i in $goboPrograms/*/Current
       do [ -d "$i/lib" ] && uniondirs="$uniondirs:$i/lib=ro"
       done
       if ! [ "$uniondirs" = "$cross_libc_libdir=rw" ]
       then Union_Mount $(Union_Backend) "$uniondirs" "$cross_libc_libdir"
       fi
   fi

   export CC HOSTCC LD
else
   cross_make_variables=""

   arch=`Get_Architecture`
   archsubdir=$bakedrecipedir/$arch
   archrecipe=$bakedrecipedir/$arch/Recipe
fi

##################################################
# Check dependencies
##################################################

app=`Get_Token "$bakedrecipedir" "/" "-2"`
versionandrevision=`Get_Token "$bakedrecipedir" "/" "-1"`

ncapp=`NamingConventions $app`
if [ "$ncapp" != "$app" ]
then Die "$app does not follow proper naming conventions. Recipe should be named $ncapp."
fi

recipedir="$bakedrecipedir"
reciperesources="$recipedir/Resources"
archreciperesources="$archsubdir/Resources"
useflags=(`UseFlags $bakedrecipedir`)

if ! Boolean "no-dependencies" && ! Boolean "no-build"
then
   Log_Normal "Checking dependencies..."
   selecteddeps=$(CheckDependencies --types=recipe --mode=missing \
     $noweb --quiet-progress $batch "$app" "$versionandrevision" \
     "recipe" "$recipedir") || Die "Aborted."
   selecteddeps=$(echo "$selecteddeps" | awk '{ print $4 }' )
   unset askeddeps
   for d_url in ${selecteddeps}
   do
      Array_Contains askeddeps "$d_url" && continue
      Compile $compileoptions --no-dependencies $d_url || exit $?
      askeddeps=("$d_url" ${askeddeps:+"${askeddeps[@]}"})
   done
fi

##################################################
# Dependency variables
##################################################

dependencies_file=$bakedrecipedir/Resources/Dependencies
if [ -f "$dependencies_file" ]
then
   while read dep
   do
      depname="$(echo $dep | cut -d ' ' -f1)"
      depverrev="$(echo $dep | cut -d ' ' -f2)"
      depver="$(echo $depverrev | cut -d '-' -f1)"
      depdir="$(echo $dep | cut -d' ' -f4)"
      lowercasename=`echo $depname | tr '[:upper:]-+' '[:lower:]__'`
      dep_settings_path="$(Get_Dir runtimeSettings ${depname} ${depver})"
      dep_variable_path="$(Get_Dir runtimeVariable ${depname} ${depver})"
      eval $lowercasename'_path="'"$depdir"'"'
      eval $lowercasename'_settings_path="'"$dep_settings_path"'"'
      eval $lowercasename'_variable_path="'"$dep_variable_path"'"'
      mark_export ${lowercasename}_path ${lowercasename}_settings_path ${lowercasename}_variable_path
   done < <(CheckDependencies --no-recursive --types=installed --quiet-progress --mode=all --file "$dependencies_file")
fi

##################################################
# Set name and version (used in Meta-recipes)
##################################################

if Is_Entry "app-name"
then appname=`Entry "app-name"`
else appname="$app"
fi

revision="`String_Revision "$versionandrevision"`"
version="`String_Version "$versionandrevision"`"

if Is_Entry "version-number"
then versionnumber=`Entry "version-number"`
else versionnumber="$version"
fi

upperversion=`Uppercase "$versionnumber"`
for upperscm in CVS SVN GIT BZR HG
do
   if [ "$upperversion" = "$upperscm" ]
   then
      versionnumber=`date +%Y%m%d`"-$upperversion"
      break
   fi
done

target=`Get_Dir runtime $appname $versionnumber`
settings_target=`Get_Dir runtimeSettings $appname $versionnumber`
variable_target="${goboVariable}"
installprefix="$target"
mark_export target settings_target variable_target version

if ! Boolean "keep" && ! Boolean "no-build"
then
   Pre_Installation_Preparation $appname $versionnumber
fi

##################################################
# Source recipe
##################################################

source "$recipe"
[ -e "$archrecipe" ] && source "$archrecipe"

if ! Boolean "no-build"
then
   if [ "$revision" ]
   then Log_Normal "Compiling $app version $version, revision $revision."
   else Log_Normal "Compiling $app version $version."
   fi
fi

# Backwards compability fix
[ "$is_compileprogram" = "yes" ] && recipe_type="configure"
[ "$is_makefile" = "yes" ] && recipe_type="makefile"
[ "$is_python" = "yes" ] && recipe_type="python"
[ "$is_perl" = "yes" ] && recipe_type="perl"
[ "$is_xmkmf" = "yes" ] && recipe_type="xmkmf"
[ "$is_meta" = "yes" ] && recipe_type="meta"
[ "$is_scons" = "yes" ] && recipe_type="scons"
[ "$is_manifest" = "yes" ] && recipe_type="manifest"

##################################################
# Set up enviroment
##################################################

if [ "${environment[*]}" ]
then
   for i in "${environment[@]}"
   do
      var=`echo $i | cut -d= -f 1`
      val=`echo $i | cut -d= -f 2-`
      eval export $var=\'$val\'
      mark_export $var
   done
fi

##################################################
# Check recipe's Compile version
##################################################

if [ -n "$compile_version" ]
then
   develrelease=`echo $compile_version | sed 's/\([0-9]*\).*/\1/g'`
   if [ "$compile_version" != "SVN" ] && [ "$develrelease" ] && [ "$develrelease" -gt "20000000" ]
   then
      compiledate=$(ls -l --time-style=+%Y%m%d $(which Compile) | awk '{print $6}')
      if [ "$compiledate" -lt "$develrelease" -a "$compilemm" != "SVN" ]
      then Boolean "batch" || Ask_Continue "Recipe was created with a development snapshot from $develrelease,\n"\
"which is more recent than the Compile version you have installed.\n"\
"Compilation may fail, upgrade ('InstallPackage Compile') is recommended."
      fi
   elif [ "$compile_version" != "$scriptVersion" ]
   then
      if echo $scriptVersion | grep -qi SVN
      then compilemm=SVN
      else compilemm=`echo $scriptVersion | sed 's/^\([0-9]*\.[0-9]*\).*$/\1/g'`
      fi
      recipemm=`echo $compile_version | sed 's/^\([0-9]*\.[0-9]*\).*$/\1/g'`
      if [ `GuessLatest $compilemm $recipemm` != $compilemm -a "$compilemm" != "SVN" ]
      then Boolean "batch" || Ask_Continue "Recipe was created with Compile $compile_version,\n"\
"which is more recent than the one you have installed.\n"\
"Compilation may fail, upgrade ('InstallPackage Compile') is recommended."
      fi
   fi
fi

##################################################
# Get the active useflags for this recipe, and
# execute the hooks here so any variable updates
# occur in time.
##################################################
for flag in "${useflags[@]}"
do
   is_function_set "using_$flag" && eval using_$flag
done

##################################################
# Meta-recipe
##################################################

if [ "$recipe_type" = "meta" ]
then
   Add_Use_Flags_Options_To_Array include
   [ -z "${include}" ] && Die "Recipe type is \"meta\", but no sub-recipes are included."
   started=no
   if ! Boolean "no-dependencies" && ! Boolean "no-build"
   then
      Log_Normal "Checking dependencies for included recipes..."
      for item in "${include[@]}"
      do
         iname=`echo "$item" | sed 's/--.*//'`
         iversion=`echo "$item" | sed 's/.*--//'`
         includedeps=$(CheckDependencies --types=recipe --mode=missing \
            $noweb $batch --quiet-progress  "$iname" "$iversion" \
            "recipe" "$recipedir") || Die "Aborted."
         selectedincludedeps="$(echo "$includedeps" | awk '{ print $4 }' ) ${selectedincludedeps:+${selectedincludedeps}}"
      done
      unset askedincludedeps
      for d_url in ${selectedincludedeps}
      do
         Array_Contains askedincludedeps "$d_url" && continue
         Compile $compileoptions --no-dependencies $d_url || exit $?
         askedincludedeps=("$d_url" ${askedincludedeps:+"${askedincludedeps[@]}"})
      done
   fi

   Array_Contains symlink_options "--conflict=overwrite" || Array_Contains symlink_options "--force" && symlink=force
   case $(Entry symlink) in
   "no" ) symlink=no ;;
   "force" ) symlink=force ;;
   esac
   [ -n "$symlink" ] && compileoptions="$compileoptions --symlink=${symlink}"

   export compileMetaRecipe=1
   for item in "${include[@]}"
   do
      iname=`echo "$item" | sed 's/--.*//'`
      iversion=`echo "$item" | sed 's/.*--//'`
      if Is_Entry_Set "start-at"
      then
         if [ "`Downcase $iname`" = "`Downcase $(Entry start-at)`" ]
         then started=yes
         fi
         if [ "$started" = "no" ]
         then continue
         fi
      fi
      in_host $0 $compileoptions --no-dependencies --keep --app-name "$appname" --version-number "$versionnumber" ${userconfigureoptions:+--configure-options="${userconfigureoptions[@]}"} "$iname" "$iversion"
      if [ "$?" -gt 0 ]
      then
         Die "Compilation of $iname $iversion failed."
      fi
   done
   Boolean "no-build" && exit 0
   install_extras
   Run_Hook pre_link || wrap_fail "Failure in pre-link operation." "yes"
   do_symlink "$appname" "$versionnumber" || wrap_fail "Symlinking failed." "yes"
   wrapup
fi

##################################################
# Part of Meta but compiled by itself
##################################################

if [ "${compileMetaRecipe}" != "1" -a -n "$part_of" ]
then
   if ! ( Boolean "install-separately" || Boolean "no-build" )
   then
      appname="$part_of"
      versionnumber=$(Get_Version "$appname" "Current")
      [ -z "$versionnumber" ] && versionnumber=$(GuessLatest "$(ls -I Settings -I Variable $goboPrograms/$appname 2>/dev/null)" 2>/dev/null)
      if [ -z "$versionnumber" ] 
      then
         if Boolean "batch" || Ask "$app is part of the $appname meta recipe, but no version of $appname could be found. Do you want to install $app separately?"
         then
            appname="$app"
            versionnumber="$version"
         else
            exit 0
         fi
      else
         Set_Boolean "keep"
      fi
      # We have to update the target name and version to reflect
      # that we install into the containing application
      target=`Get_Dir runtime $appname $versionnumber`
      settings_target=`Get_Dir runtimeSettings $appname $versionnumber`
      variable_target="${goboVariable}"
      installprefix="$target"
      # Then re-source the recipe, to update variables set in
      # the recipe
      source "$recipe"
      [ -e "$archrecipe" ] && source "$archrecipe"
   fi
fi
   
##################################################
# Construct some variable arrays
##################################################

for var in url mirror_url file file_size file_md5 cvs cvs_module svn git bzr hg
do
   eval '
      if [ -n "$'$var'" -a ! -n "${'$var's[*]}" ]
      then '$var's=("$'$var'")
      fi
   '
done

function is_scm_recipe() {
   [ "${cvss[*]}${svns[*]}${gits[*]}${bzrs[*]}${hgs[*]}" ]
}

if [ ! "${urls[*]}" ] && ! is_scm_recipe
then Die "Missing URL or repository information in recipe '$recipe'."
fi

if ! [ "${files[*]}" ]
then files=(`Map basename "${urls[@]}"`)
fi

if is_scm_recipe
then
   if [ -z "${dir}" ]
   then
      sourcedir="${appname}-${version}"
   else
      sourcedir="${dir}"
   fi
   dirs=("${sourcedir}")
   save_directory="${sourcedir%%/*}"
fi

if [ "$dir" ]
then
   if [ -z "${dirs[*]}" ]
   then dirs=("$dir")
   fi
else
   if [ -z "${dirs[*]}" ]
   then
      remove_archive_extension() { echo "$1" | sed -r "s/\.(tar|tbz|tgz|zip).*//" ;}
      String_To_Array dirs "`Map remove_archive_extension "${files[@]}"`"
   fi
fi

odirs=("${dirs[@]}")
odir=${dirs[0]}

make_basedir() { echo "$compileSourcesDir/"`echo "$1" | sed 's,/.*,,'` ;}
String_To_Array "basedirs" "`Map make_basedir "${dirs[@]}"`"

make_absolute() {
   if [ "${1:0:1}" = "/" ]
   then echo "$1"
   else echo "$compileSourcesDir/$1"
   fi
}
String_To_Array dirs "`Map make_absolute "${dirs[@]}"`"
sourcedir="${dirs[0]}"

mark_export dir sourcedir archsubdir recipedir

##################################################
# Create the cross_make_variables array
##################################################
if [ "$goboCrossCompiling" = "yes" ]
then
   if [ "$recipe_type" != "configure" ]
   then cross_array=compileMakeOptions
   else cross_array=""
   fi
   eval `combine_arrays $cross_array $cross_array cross_make_variables`
fi

##################################################
# Gather common options from the recipe
##################################################
unset buildmerged
eval `combine_arrays buildmerged compileBuildOptions compileMakeOptions make_variables build_variables`
! [ "$install_target" ] && install_target="install"
unset installmerged
eval `combine_arrays installmerged compileInstallOptions compileMakeOptions make_variables install_variables`

if [ ! -z "$goboIndex" ]
then
   buildmerged=(`echo ${buildmerged[@]} | sed "s,$target,$goboIndex,g"`)
   installmerged=(`echo ${installmerged[@]} | sed "s,$target,$goboIndex,g"`)
fi

if [ "$makefile" = "" ]
then makefile=Makefile
fi

unset keep
if Boolean "keep" || [ "$keep_existing_target" = "yes" ]
then keep="--keep"
fi

##################################################
# Compile!
##################################################

Import BuildType_${recipe_type} || wrap_fail "Unsupported recipe_type in recipe '$recipe'."

# Re-source recipe for two purposes. First let the recipe use all variables we have defined.
# Secondly by re-sourcing the recipe it can overload pre_build and similar, which is a better
# functionality than setting do_build=no and define the building procedure in the pre_build hook
source "$recipe"

# backwards compability fix, as some hooks in recipes might use "$dir"
dir="$sourcedir"
[ -e "$archrecipe" ] && source "$archrecipe"

Boolean "no-web" || [ "$nofetch" == "yes" ] || is_function_set do_fetch && do_fetch
is_scm_recipe || { is_function_set do_unpack && do_unpack; }
Boolean "no-web" || [ "$nofetch" == "yes" ] && is_scm_recipe && skippatching="yes"

cd "$sourcedir" &>/dev/null || Die "Directory $sourcedir not found."

Run_Hook pre_patch || wrap_fail "Failure in pre-patch operation."
# note: skippatching is not part of the public Compile API
[ "$skippatching" != "yes" ] && is_function_set do_patch && { do_patch || wrap_fail "Patching failed"; }

build_tree_if "$create_dirs_first" = "yes"

# This hook should really be moved one step later, but is kept here for compability
Run_Hook pre_build || wrap_fail "Failure in pre-build operation." "$create_dirs_first"
make_and_cd_to_build_dir
Boolean "lazy" || do_configuration || wrap_fail "Configuration failed." "$create_dirs_first";
if ! [ "$do_build" = "no" ]
then
do_build || wrap_fail "Build step failed." "$create_dirs_first";
fi

[ "$no_install" == "yes" ] && exit
build_tree_if "$create_dirs_first" != "yes"

Boolean "no-requirements" || assert_requirements
Run_Hook pre_install || wrap_fail "Failure in pre-install operation." "yes"
! [ "$do_install" = "no" ] && is_function_set do_install && {
   setup_sandbox_options
   do_install "$appname" "$versionnumber" || wrap_fail "Installation failed." "yes"
   Boolean "no-strip" || do_strip
}
install_extras || wrap_fail "Failed installing files." "yes"

if ! Boolean "no-symlink"
then
   Run_Hook pre_link || wrap_fail "Failure in pre-link operation." "yes"
   do_symlink "$appname" "$versionnumber" || wrap_fail "Symlinking failed." "yes"
fi

check_direct_dependencies
Run_Hook post_install || wrap_fail "Failure in post-install operation." "yes"
Boolean "no-postinstall" || Run_PostInstall "$appname" "$versionnumber" "" "" "" || wrap_fail "Failure in post-install operation." "yes"

wrapup
