#!/bin/sh -e

datadir="/Programs/BuildLiveCD/Current/Data"

root="$1"
shift
packagedir="$1"
shift
packagelist="$1"
packagelists="$@"

if ! [ -d "$packagedir" -a -f "$packagelist" ]
then
   echo "Usage: BuildRoot <root> <packagedir> <packagelist1> [packagelist2] ..."
   [ -d "$packagedir" ] ||  echo "   $packagedir does not exist"
   [ -f "$packagelist" ] || echo "   $packagelist does not exist"
   exit 1
fi

if [ "$UID" != "0" ]
then
    echo "Running as superuser."
    exec sudo -u "#0" $0 $*
fi


function get_package_name() {
   packagename=`echo $1 | awk {'print $1'}`

   if grep -q "$packagename" "$datadir/Packages-List-GoboLinuxTools"
   then packagever=`date +%Y%m%d`
   else packagever=`echo $1 | awk {'print $2'}`
   fi
   pkg=`ls $packagedir/${packagename}--${packagever}--* 2> /dev/null || true`
   [ -z "$pkg" ] && pkg=`ls $packagedir/${packagename}--* 2> /dev/null || true`
   if [ -z "$pkg" ]
   then
      echo "*** Package $packagename $packagever could not be filled. ***"
      exit 1
   fi

   echo "$pkg"
}


cat $packagelists | while read line
do
   # just ensure that required packages are found
   get_package_name "$line" > /dev/null
done


function do_link() {
   if [ -d "$root/$1" ]
   then
      pushd $root/$2 &>/dev/null
      (
         export verboseFD=100
         export normalFD=101
         export terseFD=102
         export errorFD=103
         export debugFD=104
         export logFD=105
         export questionFD=106
         eval "exec $verboseFD>/dev/null"
         eval "exec $normalFD>/dev/null"
         eval "exec $terseFD<&2"
         eval "exec $errorFD<&2"
         eval "exec $debugFD>/dev/null"
         eval "exec $logFD>/dev/null"

         export goboPrefix=$root
         export goboPrograms=$root/Programs 
         LinkOrExpandAll $root/$1 --relative --no-follow
      )
      popd &>/dev/null
   fi
}


function symlink_program() {
   full_path="$1"
   root=`readlink -f $2`
   gobolinks=/System/Links
 
   name=$(basename $(dirname $full_path))
   version=$(basename ${full_path})
   #echo "Linking ${full_path} inside ${gobolinks}" 1>&2
   
   do_link ${full_path}/bin ${gobolinks}/Executables
   do_link ${full_path}/sbin ${gobolinks}/Executables
   do_link ${full_path}/Resources/Wrappers ${gobolinks}/Executables
   do_link ${full_path}/Resources/Tasks ${gobolinks}/Tasks
   do_link ${full_path}/lib ${gobolinks}/Libraries
   do_link ${full_path}/man ${gobolinks}/Manuals
   do_link ${full_path}/include ${gobolinks}/Headers
   do_link ${full_path}/../Settings ${gobolinks}/../Settings
   do_link ${full_path}/Shared ${gobolinks}/Shared

   [ -f "${root}${full_path}/Resources/Environment" ] && \
   ln -nfs ../../../Programs/${name}/${version}/Resources/Environment ${root}${gobolinks}/Environment/${name}--${version}
   ln -nfs $version ${root}$(dirname ${full_path})/Current
}

function program_md5() {
   #
   # BIG FAT WARNING:
   # Assuming we have only one version per program
   #
   name="$1"
   cat "${root}"/../Checksums/$name--* 2> /dev/null | tail -1 || echo "0000"
}

function install_package() {
   package=`readlink -f "$1"`
   root="$2"
   
   base=$(basename $package)
   name=${base%%--*}
   version=${base#*--}
   version=${version%%--*}
   
   #
   # BIG FAT WARNING:
   # Assuming we have only one version per program
   #
   packagemd5=`md5sum $package`
   if [ -d "$root/Programs/$name" ]
   then 
      if [ "`program_md5 $name`" =  "$packagemd5" ]
      then
         echo "Keeping $name $version..."

         # just keep package: md5 matches last installation
         return
      else
         echo "Removing existing $name..."

         # cleanup old md5 file
         rm -f "${root}"/../Checksums/$name--*
         # remove the installed package: $package was updated 
         rm -rf "$root/Programs/$name"
      fi
   fi
   echo "$packagemd5" > "${root}"/../Checksums/$name--$version
   
   echo "Installing $name $version..."
   pushd "$root/Programs" &> /dev/null
   tar xjpf "$package"

   dsettings="$name/$version/Resources/Defaults/Settings"
   [ -d "$dsettings" ] && cp -a "$dsettings" "$name/Settings"
   dvariable="$name/$version/Resources/Defaults/Variable"
   if [ -d "$dvariable" ]
   then
      cp -a "$dvariable" /System/Variable
      ln -s /System/Variable "$name/Variable"
   fi
   
   # Handling Unmanaged files (emulating InstallPackage)
   if [ -d "$name/$version/Resources/Unmanaged/" ]
   then
      cp -fa $name/$version/Resources/Unmanaged/* ../ # warning: assuming we are under $root/Programs
   fi
   
   popd &> /dev/null
   
   symlink_program /Programs/$name/$version $root

}

echo "BuildRoot: Building root $root..."

#
# Base Directories
#
mkdir -p $root
mkdir -p $root/System/Links/Executables
mkdir -p $root/System/Links/Environment
mkdir -p $root/System/Links/Libraries
mkdir -p $root/System/Links/Headers
mkdir -p $root/System/Links/Manuals
mkdir -p $root/System/Links/Shared
mkdir -p $root/System/Links/Tasks
mkdir -p $root/System/Settings
mkdir -p $root/System/Variable
mkdir -p $root/System/Variable/tmp; chmod a+w $root/System/Variable/tmp; chmod +t $root/System/Variable/tmp;  
mkdir -p $root/System/Variable/log
mkdir -p $root/System/Variable/run
mkdir -p $root/System/Kernel
mkdir -p $root/System/Kernel/Boot
mkdir -p $root/System/Kernel/Objects
mkdir -p $root/System/Kernel/Modules
mkdir -p $root/System/Kernel/Devices
mkdir -p $root/System/Kernel/Status
mkdir -p $root/Users
mkdir -p $root/Users/root
mkdir -p $root/Files
mkdir -p $root/Files/Compile
mkdir -p $root/Files/Compile/Archives
mkdir -p $root/Files/Compile/Sources
mkdir -p $root/Files/Compile/Store
mkdir -p $root/Depot
mkdir -p $root/Mount
mkdir -p $root/Mount/.Pivot
mkdir -p $root/Mount/CD-ROM
mkdir -p $root/Mount/GoboLinux
mkdir -p $root/Mount/Floppy
mkdir -p $root/Mount/TmpFS
mkdir -p $root/Programs

#
# Legacy Links
#
mkdir -p $root/usr

ln -nfs /System/Kernel/Objects $root/sys
ln -nfs /System/Kernel/Devices $root/dev
ln -nfs /System/Kernel/Status $root/proc
ln -nfs /System/Variable $root/var
ln -nfs /System/Variable/tmp $root/tmp
ln -nfs /System/Links/Libraries $root/lib
ln -nfs /System/Settings $root/etc
ln -nfs /System/Links/Executables $root/bin
ln -nfs /System/Links/Executables $root/sbin

ln -nfs /System/Kernel/Modules $root/System/Links/Libraries/modules

ln -nfs . $root/usr/X11R6
ln -nfs . $root/usr/local
ln -nfs /System/Links/Executables $root/usr/bin
ln -nfs /System/Links/Headers $root/usr/include
ln -nfs /System/Links/Libraries $root/usr/lib
ln -nfs /System/Links/Manuals $root/usr/man
ln -nfs /System/Links/Executables $root/usr/sbin
ln -nfs /System/Links/Shared $root/usr/share

[ -e $root/System/Kernel/Devices/null ] || mknod -m0666 $root/System/Kernel/Devices/null c 1 3
[ -e $root/System/Kernel/Devices/null ] || mknod -m0600 $root/System/Kernel/Devices/console c 5 1

pushd $root/System/Settings &> /dev/null
# MakeSystemSettings overwrites existing files
MakeSystemSettings
popd &> /dev/null

mkdir -p "${root}"/../Checksums/

for packagelist in ${packagelists[@]}
do
   echo "Installing packages from $packagelist"
   cat $packagelist | while read line
   do
      pkg=`get_package_name $line`
      install_package "$pkg" "$root"
   done
done

[ -f "${root}/System/Links/Environment/Cache}" ] && rm ${root}/System/Links/Environment/Cache
for link in ${root}/System/Links/Environment/*--*
do
   cat ${link} >>${root}/System/Links/Environment/Cache
done

# SymlinkProgram --relative is not perfect yet, but, ideally, we should call the following command
#echo "Checking for broken links at ${root}/System/Links/"
#find ${root}/System/Links/ | RemoveBroken

exit 0
