#!/bin/sh

if ! which mksquashfs &> /dev/null
then
   echo "You need to install SquashFS-Tools."
   exit 1
fi

for conf in ./Master.conf /System/Settings/BuildLiveCD/Master.conf fail
do
   if [ "$conf" = "fail" ]
   then
      echo "Could not find Master.conf."
      exit 1
   elif [ -e $conf ]
   then
      source $conf
      break
   fi
done

if [ "$UID" != "0" ]
then
    echo "Running as superuser."
    exec sudo -u "#0" $0 $*
fi

start_at=`echo $1| tr 'A-Z' 'a-z'`

mkdir -p output
mkdir -p output/ISO
if [ "$start_at" = "layer1" ] || ! [ -d "output/Layer1" ]
then
    mkdir -p output/Layer1
    BuildRoot "output/Layer1" "Packages" "Packages/package.list"
    [ "$?" = "0" ] || exit 1

    # Add few items to layer1
    mkdir -p output/Layer1/Files
    cp -ar Ext_work/Gobo-Files/* output/Layer1/Files
    cp -ar Ext_work/Files-Fonts/* output/Layer1/Files
    mkdir -p output/Layer1/Files/Documentation
    cp -ar Ext_work/Linux-HOWTOs output/Layer1/Files/Documentation
    cp -ar Ext_work/Linux-Kernel/* output/Layer1

    # Clean CVS files from Layer1
    find output/Layer1 -name CVS | grep -v Programs/CVS | xargs rm -rf
    start_at="squashfs"
fi

if [ "$start_at" = "squashfs" ] || ! [ -f "output/ISO/GoboLinux-files.squashfs" ]
then
    # Freshen build_chroots
    echo "Freshen"
    unionfs_dirs=""
    for layer in "${build_layers[@]}"
    do

	# Don't touch touch Layer1
	[ "$layer" = "${build_layers[0]}" ] && continue

        unionfs_dirs="$unionfs_dirs:${layer}=ro"
        layer_bn=`basename $layer`
	echo "   output/$layer_bn"
	mkdir -p output/$layer_bn
	cp -ar $layer/. output/$layer_bn
	# Clean layer of CVS
	find output/$layer_bn -name CVS | grep -v Programs/CVS | xargs rm -rf
    done

    mkdir -p output/Environment
    echo "Unionfs mounting layers."
    tmp_mp=`mktemp -d /tmp/finalize_layer-XXXXX`
    unionfs_dirs="dirs=${tmp_mp}=rw:${build_layers[0]]}=ro${unionfs_dirs}"
    echo mount -t unionfs -o ${unionfs_dirs} none output/Environment
    mount -t unionfs -o ${unionfs_dirs} none output/Environment

    mkdir -p output/Checksums
    
    function ld_so_cache_changed() {
       if grep -q "output/Environment/Programs/Glibc/Settings/ld.so.cache" /tmp/newer.txt
       then
          diff output/ld.so.cache.sum output/ld.so.cache.sum.old &> /dev/null
          if [ $? -ne 0 ]
          then
             cp output/ld.so.cache.sum output/ld.so.cache.sum.old
             return 0
          fi
       else
          return 1
       fi
    }
    
    function mksquashfs_on_demand() {
       out="$1"
       shift
       bn=`basename "$out"`
       # sumsfile=output/Checksums/$bn.sums
       echo "Checking if $bn needs updating..."
       find "$@" -type f -newer "$out" 2> /dev/null > /tmp/newer.txt
       echo ==========
       echo Changes:
       echo ----------
       cat /tmp/newer.txt
       echo ==========
       diffs=`cat /tmp/newer.txt | grep -v "output/Environment/Programs/Glibc/Settings/ld.so.cache" | wc -l`
       if [ ! -e "$out" ] || [ $diffs -gt 0 ] || ld_so_cache_changed
       #find "$@" | grep -v Devices | xargs -n 100 md5sum > $sumsfile.new 2> /dev/null
       #if ! diff -q $sumsfile $sumsfile.new
       then
          echo "Creating squashfs compressed file $bn..."
          # mv $sumsfile.new $sumsfile
          nice -20 mksquashfs "$@" "$out" -noappend
       else
          echo "Mksquashfs not needed for $bn."
       fi
       rm /tmp/newer.txt
    }

    # Final actions on Environment
    chroot output/Environment /bin/ldconfig
    md5sum output/Environment/Programs/Glibc/Settings/ld.so.cache > output/ld.so.cache.sum
    # compress the uncompressed files into a squashfs file

    time mksquashfs_on_demand output/ISO/GoboLinux-files.squashfs output/Environment/Files
    time mksquashfs_on_demand output/ISO/GoboLinux-programs-a-e.squashfs output/Environment/Programs/[A-E]*
    time mksquashfs_on_demand output/ISO/GoboLinux-programs-f-j.squashfs output/Environment/Programs/[F-J]*
    time mksquashfs_on_demand output/ISO/GoboLinux-programs-k-o.squashfs output/Environment/Programs/[K-O]*
    time mksquashfs_on_demand output/ISO/GoboLinux-programs-p-t.squashfs output/Environment/Programs/[P-T]*
    time mksquashfs_on_demand output/ISO/GoboLinux-programs-u-z.squashfs output/Environment/Programs/[U-Z]*
    time mksquashfs_on_demand output/ISO/GoboLinux-rest.squashfs `ls -d output/Environment/* | grep -v Files | grep -v Programs`

    umount output/Environment
    rm -rf $tmp_mp
    start_at="initrd"
fi

cp -ra Ext_work/ISO_Base/$arch/. output/ISO

if [ "$start_at" = "initrd" ] || ! [ -f "output/ISO/isolinux/initrd.gz" ]
then
    #Rebuild initrd
    echo "Building initrd.gz"
    rm -rf "output/InitRD"
    mkdir -p "output/InitRD"
    cp -ra Ext_work/InitRD/. output/InitRD
    cp Ext_work/Linux-Kernel/System/Kernel/Modules/2.6.15.2-Gobo/kernel/drivers/usb/storage/usb-storage.ko output/InitRD/System/Kernel/Modules/
    cp Ext_work/Linux-Kernel/System/Kernel/Boot/kernel-2.6.15.2-Gobo output/ISO/isolinux/kernel
    mkfs.cramfs output/InitRD output/ISO/isolinux/initrd
fi

if [ "$start_at" = "" ]
then
    echo "Starting at last stage (iso)."
    echo "    if you want earlier stage specify one of:"
    echo "    layer1, squashfs, initrd, iso"
    echo ""
    echo "==================================================================="
    echo ""

fi

# having the squashfs file, you can prepare the bootable iso
echo "Building ISO..."
iso_name="output/GoboLinux-NoVersion.iso"
time nice -20 mkisofs -R -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table output/ISO  > $iso_name
